import numpy as np
import patterns as patt
from linearalg import linalg
from linearalg import string_functions as sf


LINALG_OPS = ('dot', 'cross', 'angle', 'plane',
              'det', 'matmul', 'matsum', 'eigenvals',
              'inverse')


def response(command):

    try:
        operation = patt.OPS.findall(command)[0]

    except IndexError:
        return f'"{command}" is not a valid command!'

    if operation in LINALG_OPS:
        return linalg_response(operation, command)
    else:
        return f'"{operation}" is not a valid operation!'


def linalg_response(operation, command):
    '''
    Get vectors, normal vectors ,points & matrices
    '''
    catched_vecs = [vec.group(0) for vec in patt.VEC.finditer(command)]
    catched_nvecs = [nvec for nvec in patt.NVEC.findall(command)]
    catched_pts = [pt for pt in patt.PT.findall(command)]
    catched_mxs = [mx.group(0)for mx in patt.MATRIX.finditer(command)]

    # Too much data
    if len(catched_nvecs) > 1 or len(catched_vecs) > 2 or len(catched_pts) > 3:
        return f'Too much operands for {operation} operation!'

    if len(catched_mxs) > 0 and (len(catched_nvecs) > 0 or len(catched_vecs) > 0 or len(catched_pts) > 0):
        return f'Incorrect operands for {operation} operation!'

    # Insufficient data
    if len(catched_vecs) == 0 and len(catched_pts) == 0 and len(catched_mxs) == 0:
        return f'Invalid operands for {operation} operation!'

    try:
        # vectors [1xn array]
        vectors = [sf.vector_to_array(vec) for vec in catched_vecs]

        # normal vectors [1x3 array]
        nvectors = [sf.list_to_array(nvec) for nvec in catched_nvecs]

        # points [1x3 array]
        points = [sf.list_to_array(pt) for pt in catched_pts]

        # Matrices [nxn array]
        matrices = [sf.matrix_to_array(matrix) for matrix in catched_mxs]

    except ZeroDivisionError:
        return 'You cannot divide by Zero!'

    ### VECTORS OPERATIONS ###
    if operation in ('dot', 'cross', 'angle'):
        # Incorrect data
        if len(vectors) != 2 or len(points) > 0 or len(nvectors) > 0:
            return f'Invalid operands for {operation} operation!'

        # Vectors of differents dimension
        if len(vectors[0]) != len(vectors[1]):
            return r'Vectors must have the same dimension!'

        # Operations:
        if operation == 'dot':
            return str(np.dot(vectors[0], vectors[1]))

        if operation == 'cross':
            if len(vectors[0]) != 3 or len(vectors[1]) != 3:
                return f'Vectors must be 3-dimensional!'
            return sf.array_to_vector(np.cross(vectors[0], vectors[1]))

        if operation == 'angle':
            return str(linalg.vectors_angles(vectors[0], vectors[1])) + 'Â°'

    ### PLANE OPERATIONS ###
    if operation == 'plane':

        # Plane with a normal vector and a planes point
        if len(nvectors) == 1 and len(points) == 1:

            if len(vectors) > 0:
                return f'Invalid operands for {operation} operation!'

            return linalg.normal_point_plane(nvectors[0], points[0])

        # Plane generated by 2 planes vector and a point
        elif len(vectors) == 2 and len(points) == 1:

            if len(nvectors) > 0:
                return f'Invalid operands for {operation} operation!'

            return linalg.vectors_and_point_plane(vectors[0], vectors[1], points[0])

        # Plane containing 3 points
        elif len(points) == 3:

            if len(vectors) > 0 or len(nvectors) > 0:
                f'Invalid operands for {operation} operation!'

            v1 = points[1] - points[0]
            v2 = points[2] - points[0]

            return linalg.vectors_and_point_plane(v1, v2, points[0])

        else:
            return f'Invalid operands for {operation} operation!'

    ### MATRICES OPERATIONS ###
    # single matrix operations
    if operation in ('det', 'inverse', 'eigenvals'):
        if len(matrices) > 1:
            return f'{operation.capitalize()} operation only takes one matrix!'

        matrix = matrices[0]

        if not linalg.is_square(matrix):
            return 'The matrix entered is not square!'

        if operation == 'det':
            return str(np.linalg.det(matrix))

        if operation == 'inverse':
            try:
                return sf.array_to_matrix(np.linalg.inv(matrix))
            except Exception:
                return 'The matrix entered has no inverse!'

        if operation == 'eigenvals':
            return linalg.eigen_values(matrix)

    # multiple matrices operations
    if operation in ('matmul', 'matsum'):
        if len(matrices) < 2:
            return f'{operation.capitalize()} requires two or more matrices!'

        if operation == 'matmul':
            try:
                return sf.array_to_matrix(np.matmul(*matrices))
            except:
                return 'The multiplication of the entered matrices is not defined!'

        if operation == 'matsum':
            try:
                return sf.array_to_matrix(linalg.matrix_addition(matrices))
            except ValueError:
                return 'Matrices must have an equal number of rows and columns to be added!'


if __name__ == '__main__':
    while True:
        txt = input('$ ')
        if txt == 'exit':
            break
        print(response(txt))
